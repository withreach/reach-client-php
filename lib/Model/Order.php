<?php
/**
 * Order
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Reach's Drop-In API
 *
 * API definition for Reach's Drop-In API's
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.34
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * Order Class Doc Comment
 *
 * @category Class
 * @description A Reach order, representing a payment attempt. See https://docs.withreach.com/docs/states-and-events for information on the order lifecycle. If created by a session, the presence indicates the session is completed and the payment is being processed.
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Order implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'Order';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'order_id' => 'string',
'state' => 'string',
'merchant_reference' => 'string',
'billing_profile' => 'AllOfOrderBillingProfile',
'billing_profile_id' => 'string',
'billing_profile_reference' => 'string',
'currency' => 'string',
'items' => '\Swagger\Client\Model\Item[]',
'payment' => 'AllOfOrderPayment',
'contract_id' => 'string',
'device_fingerprint' => 'string',
'discounts' => '\Swagger\Client\Model\Discount[]',
'shipping_details' => '\Swagger\Client\Model\ShippingDetails',
'tax_amount' => 'float',
'via_agent' => 'bool',
'accept_liability' => 'bool',
'auto_capture' => 'bool',
'open_contract' => 'bool',
'meta' => '\Swagger\Client\Model\Meta',
'under_review' => 'bool',
'chargeback' => 'bool',
'reason' => 'string',
'expiry' => 'string',
'action' => 'AllOfOrderAction',
'times' => 'AllOfOrderTimes'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'order_id' => 'uuid',
'state' => null,
'merchant_reference' => null,
'billing_profile' => null,
'billing_profile_id' => 'uuid',
'billing_profile_reference' => null,
'currency' => null,
'items' => null,
'payment' => null,
'contract_id' => 'uuid',
'device_fingerprint' => null,
'discounts' => null,
'shipping_details' => null,
'tax_amount' => null,
'via_agent' => null,
'accept_liability' => null,
'auto_capture' => null,
'open_contract' => null,
'meta' => null,
'under_review' => null,
'chargeback' => null,
'reason' => null,
'expiry' => null,
'action' => null,
'times' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'order_id' => 'OrderId',
'state' => 'State',
'merchant_reference' => 'MerchantReference',
'billing_profile' => 'BillingProfile',
'billing_profile_id' => 'BillingProfileId',
'billing_profile_reference' => 'BillingProfileReference',
'currency' => 'Currency',
'items' => 'Items',
'payment' => 'Payment',
'contract_id' => 'ContractId',
'device_fingerprint' => 'DeviceFingerprint',
'discounts' => 'Discounts',
'shipping_details' => 'ShippingDetails',
'tax_amount' => 'TaxAmount',
'via_agent' => 'ViaAgent',
'accept_liability' => 'AcceptLiability',
'auto_capture' => 'AutoCapture',
'open_contract' => 'OpenContract',
'meta' => 'Meta',
'under_review' => 'UnderReview',
'chargeback' => 'Chargeback',
'reason' => 'Reason',
'expiry' => 'Expiry',
'action' => 'Action',
'times' => 'Times'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'order_id' => 'setOrderId',
'state' => 'setState',
'merchant_reference' => 'setMerchantReference',
'billing_profile' => 'setBillingProfile',
'billing_profile_id' => 'setBillingProfileId',
'billing_profile_reference' => 'setBillingProfileReference',
'currency' => 'setCurrency',
'items' => 'setItems',
'payment' => 'setPayment',
'contract_id' => 'setContractId',
'device_fingerprint' => 'setDeviceFingerprint',
'discounts' => 'setDiscounts',
'shipping_details' => 'setShippingDetails',
'tax_amount' => 'setTaxAmount',
'via_agent' => 'setViaAgent',
'accept_liability' => 'setAcceptLiability',
'auto_capture' => 'setAutoCapture',
'open_contract' => 'setOpenContract',
'meta' => 'setMeta',
'under_review' => 'setUnderReview',
'chargeback' => 'setChargeback',
'reason' => 'setReason',
'expiry' => 'setExpiry',
'action' => 'setAction',
'times' => 'setTimes'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'order_id' => 'getOrderId',
'state' => 'getState',
'merchant_reference' => 'getMerchantReference',
'billing_profile' => 'getBillingProfile',
'billing_profile_id' => 'getBillingProfileId',
'billing_profile_reference' => 'getBillingProfileReference',
'currency' => 'getCurrency',
'items' => 'getItems',
'payment' => 'getPayment',
'contract_id' => 'getContractId',
'device_fingerprint' => 'getDeviceFingerprint',
'discounts' => 'getDiscounts',
'shipping_details' => 'getShippingDetails',
'tax_amount' => 'getTaxAmount',
'via_agent' => 'getViaAgent',
'accept_liability' => 'getAcceptLiability',
'auto_capture' => 'getAutoCapture',
'open_contract' => 'getOpenContract',
'meta' => 'getMeta',
'under_review' => 'getUnderReview',
'chargeback' => 'getChargeback',
'reason' => 'getReason',
'expiry' => 'getExpiry',
'action' => 'getAction',
'times' => 'getTimes'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const STATE_AUTHENTICATING = 'Authenticating';
const STATE_PENDING = 'Pending';
const STATE_PROCESSING = 'Processing';
const STATE_PAYMENT_AUTHORIZED = 'PaymentAuthorized';
const STATE_PROCESSED = 'Processed';
const STATE_PROCESSING_FAILED = 'ProcessingFailed';
const STATE_CANCELLED = 'Cancelled';
const STATE_DECLINED = 'Declined';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_AUTHENTICATING,
self::STATE_PENDING,
self::STATE_PROCESSING,
self::STATE_PAYMENT_AUTHORIZED,
self::STATE_PROCESSED,
self::STATE_PROCESSING_FAILED,
self::STATE_CANCELLED,
self::STATE_DECLINED,        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['order_id'] = isset($data['order_id']) ? $data['order_id'] : null;
        $this->container['state'] = isset($data['state']) ? $data['state'] : null;
        $this->container['merchant_reference'] = isset($data['merchant_reference']) ? $data['merchant_reference'] : null;
        $this->container['billing_profile'] = isset($data['billing_profile']) ? $data['billing_profile'] : null;
        $this->container['billing_profile_id'] = isset($data['billing_profile_id']) ? $data['billing_profile_id'] : null;
        $this->container['billing_profile_reference'] = isset($data['billing_profile_reference']) ? $data['billing_profile_reference'] : null;
        $this->container['currency'] = isset($data['currency']) ? $data['currency'] : null;
        $this->container['items'] = isset($data['items']) ? $data['items'] : null;
        $this->container['payment'] = isset($data['payment']) ? $data['payment'] : null;
        $this->container['contract_id'] = isset($data['contract_id']) ? $data['contract_id'] : null;
        $this->container['device_fingerprint'] = isset($data['device_fingerprint']) ? $data['device_fingerprint'] : null;
        $this->container['discounts'] = isset($data['discounts']) ? $data['discounts'] : null;
        $this->container['shipping_details'] = isset($data['shipping_details']) ? $data['shipping_details'] : null;
        $this->container['tax_amount'] = isset($data['tax_amount']) ? $data['tax_amount'] : null;
        $this->container['via_agent'] = isset($data['via_agent']) ? $data['via_agent'] : null;
        $this->container['accept_liability'] = isset($data['accept_liability']) ? $data['accept_liability'] : null;
        $this->container['auto_capture'] = isset($data['auto_capture']) ? $data['auto_capture'] : null;
        $this->container['open_contract'] = isset($data['open_contract']) ? $data['open_contract'] : null;
        $this->container['meta'] = isset($data['meta']) ? $data['meta'] : null;
        $this->container['under_review'] = isset($data['under_review']) ? $data['under_review'] : null;
        $this->container['chargeback'] = isset($data['chargeback']) ? $data['chargeback'] : null;
        $this->container['reason'] = isset($data['reason']) ? $data['reason'] : null;
        $this->container['expiry'] = isset($data['expiry']) ? $data['expiry'] : null;
        $this->container['action'] = isset($data['action']) ? $data['action'] : null;
        $this->container['times'] = isset($data['times']) ? $data['times'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['order_id'] === null) {
            $invalidProperties[] = "'order_id' can't be null";
        }
        if ($this->container['state'] === null) {
            $invalidProperties[] = "'state' can't be null";
        }
        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($this->container['state']) && !in_array($this->container['state'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'state', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['merchant_reference'] === null) {
            $invalidProperties[] = "'merchant_reference' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets order_id
     *
     * @return string
     */
    public function getOrderId()
    {
        return $this->container['order_id'];
    }

    /**
     * Sets order_id
     *
     * @param string $order_id UUID identifying the individual Order.
     *
     * @return $this
     */
    public function setOrderId($order_id)
    {
        $this->container['order_id'] = $order_id;

        return $this;
    }

    /**
     * Gets state
     *
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param string $state Order state. See: https://docs.withreach.com/docs/states-and-events
     *
     * @return $this
     */
    public function setState($state)
    {
        $allowedValues = $this->getStateAllowableValues();
        if (!in_array($state, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'state', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets merchant_reference
     *
     * @return string
     */
    public function getMerchantReference()
    {
        return $this->container['merchant_reference'];
    }

    /**
     * Sets merchant_reference
     *
     * @param string $merchant_reference Unique identifier provided by merchant.
     *
     * @return $this
     */
    public function setMerchantReference($merchant_reference)
    {
        $this->container['merchant_reference'] = $merchant_reference;

        return $this;
    }

    /**
     * Gets billing_profile
     *
     * @return AllOfOrderBillingProfile
     */
    public function getBillingProfile()
    {
        return $this->container['billing_profile'];
    }

    /**
     * Sets billing_profile
     *
     * @param AllOfOrderBillingProfile $billing_profile Full consumer billing information. Supplying this creates a new BillingProfile that can be referenced in future requests with either the supplied BillingProfileReference or the generated BillingProfileId. Exactly one of BillingProfile, BillingProfileId or BillingprofileReference are required.
     *
     * @return $this
     */
    public function setBillingProfile($billing_profile)
    {
        $this->container['billing_profile'] = $billing_profile;

        return $this;
    }

    /**
     * Gets billing_profile_id
     *
     * @return string
     */
    public function getBillingProfileId()
    {
        return $this->container['billing_profile_id'];
    }

    /**
     * Sets billing_profile_id
     *
     * @param string $billing_profile_id Corresponds to the BillingProfileId returned in a BillingProfile. Can be passed in to reference an existing billing profile instead of creating a new one. Exactly one of BillingProfile, BillingProfileId or BillingprofileReference are required.
     *
     * @return $this
     */
    public function setBillingProfileId($billing_profile_id)
    {
        $this->container['billing_profile_id'] = $billing_profile_id;

        return $this;
    }

    /**
     * Gets billing_profile_reference
     *
     * @return string
     */
    public function getBillingProfileReference()
    {
        return $this->container['billing_profile_reference'];
    }

    /**
     * Sets billing_profile_reference
     *
     * @param string $billing_profile_reference Merchant supplied reference that uniquely maps to a BillingProfile. Can be passed in to reference an existing BillingProfile. Exactly one of BillingProfile, BillingProfileId or BillingprofileReference are required.
     *
     * @return $this
     */
    public function setBillingProfileReference($billing_profile_reference)
    {
        $this->container['billing_profile_reference'] = $billing_profile_reference;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string $currency Three-character ISO-4217 currency code used to process the payment.
     *
     * @return $this
     */
    public function setCurrency($currency)
    {
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets items
     *
     * @return \Swagger\Client\Model\Item[]
     */
    public function getItems()
    {
        return $this->container['items'];
    }

    /**
     * Sets items
     *
     * @param \Swagger\Client\Model\Item[] $items List of items to be paid. At least one Item must be supplied in requests. The sum total of the item amounts will be added to the TotalAmount
     *
     * @return $this
     */
    public function setItems($items)
    {
        $this->container['items'] = $items;

        return $this;
    }

    /**
     * Gets payment
     *
     * @return AllOfOrderPayment
     */
    public function getPayment()
    {
        return $this->container['payment'];
    }

    /**
     * Sets payment
     *
     * @param AllOfOrderPayment $payment Payment information, such as card or offline data. Required in requests if ContractId is not present.
     *
     * @return $this
     */
    public function setPayment($payment)
    {
        $this->container['payment'] = $payment;

        return $this;
    }

    /**
     * Gets contract_id
     *
     * @return string
     */
    public function getContractId()
    {
        return $this->container['contract_id'];
    }

    /**
     * Sets contract_id
     *
     * @param string $contract_id Reach-generated ID of an existing contract. Can be supplied in lieu of a Payment object. Will be returned in the response if OpenContract is set to true.
     *
     * @return $this
     */
    public function setContractId($contract_id)
    {
        $this->container['contract_id'] = $contract_id;

        return $this;
    }

    /**
     * Gets device_fingerprint
     *
     * @return string
     */
    public function getDeviceFingerprint()
    {
        return $this->container['device_fingerprint'];
    }

    /**
     * Sets device_fingerprint
     *
     * @param string $device_fingerprint Device fingerprint - see https://docs.withreach.com/reference/fingerprint-1
     *
     * @return $this
     */
    public function setDeviceFingerprint($device_fingerprint)
    {
        $this->container['device_fingerprint'] = $device_fingerprint;

        return $this;
    }

    /**
     * Gets discounts
     *
     * @return \Swagger\Client\Model\Discount[]
     */
    public function getDiscounts()
    {
        return $this->container['discounts'];
    }

    /**
     * Sets discounts
     *
     * @param \Swagger\Client\Model\Discount[] $discounts List of discounts. The sum of the discounts amounts will be subtracted from the TotalAmount
     *
     * @return $this
     */
    public function setDiscounts($discounts)
    {
        $this->container['discounts'] = $discounts;

        return $this;
    }

    /**
     * Gets shipping_details
     *
     * @return \Swagger\Client\Model\ShippingDetails
     */
    public function getShippingDetails()
    {
        return $this->container['shipping_details'];
    }

    /**
     * Sets shipping_details
     *
     * @param \Swagger\Client\Model\ShippingDetails $shipping_details shipping_details
     *
     * @return $this
     */
    public function setShippingDetails($shipping_details)
    {
        $this->container['shipping_details'] = $shipping_details;

        return $this;
    }

    /**
     * Gets tax_amount
     *
     * @return float
     */
    public function getTaxAmount()
    {
        return $this->container['tax_amount'];
    }

    /**
     * Sets tax_amount
     *
     * @param float $tax_amount Tax to be applied to the order. In the consumer currency, max precision of 2 digits. TaxAmount will be added to the TotalAmount.
     *
     * @return $this
     */
    public function setTaxAmount($tax_amount)
    {
        $this->container['tax_amount'] = $tax_amount;

        return $this;
    }

    /**
     * Gets via_agent
     *
     * @return bool
     */
    public function getViaAgent()
    {
        return $this->container['via_agent'];
    }

    /**
     * Sets via_agent
     *
     * @param bool $via_agent Indicates that this order is being made by an agent, and not the end consumer. If false or not present, the order is assumed to be placed by the end consumer.
     *
     * @return $this
     */
    public function setViaAgent($via_agent)
    {
        $this->container['via_agent'] = $via_agent;

        return $this;
    }

    /**
     * Gets accept_liability
     *
     * @return bool
     */
    public function getAcceptLiability()
    {
        return $this->container['accept_liability'];
    }

    /**
     * Sets accept_liability
     *
     * @param bool $accept_liability If true, the merchant accepts financial liability for this order.
     *
     * @return $this
     */
    public function setAcceptLiability($accept_liability)
    {
        $this->container['accept_liability'] = $accept_liability;

        return $this;
    }

    /**
     * Gets auto_capture
     *
     * @return bool
     */
    public function getAutoCapture()
    {
        return $this->container['auto_capture'];
    }

    /**
     * Sets auto_capture
     *
     * @param bool $auto_capture If true or the payment method used by the consumer does not support pre-authorization, the payment will be completed. If false or not present, and the payment method supports pre-authorization, the order will be left in the PaymentAuthorized state and the merchant must capture the order using a capture request.
     *
     * @return $this
     */
    public function setAutoCapture($auto_capture)
    {
        $this->container['auto_capture'] = $auto_capture;

        return $this;
    }

    /**
     * Gets open_contract
     *
     * @return bool
     */
    public function getOpenContract()
    {
        return $this->container['open_contract'];
    }

    /**
     * Sets open_contract
     *
     * @param bool $open_contract If true, a contract (used for recurring billing, subscriptions, stored payment options, etc.) will be opened if possible. If false or not present, the order will not open a contract.
     *
     * @return $this
     */
    public function setOpenContract($open_contract)
    {
        $this->container['open_contract'] = $open_contract;

        return $this;
    }

    /**
     * Gets meta
     *
     * @return \Swagger\Client\Model\Meta
     */
    public function getMeta()
    {
        return $this->container['meta'];
    }

    /**
     * Sets meta
     *
     * @param \Swagger\Client\Model\Meta $meta meta
     *
     * @return $this
     */
    public function setMeta($meta)
    {
        $this->container['meta'] = $meta;

        return $this;
    }

    /**
     * Gets under_review
     *
     * @return bool
     */
    public function getUnderReview()
    {
        return $this->container['under_review'];
    }

    /**
     * Sets under_review
     *
     * @param bool $under_review This will be returned as true if a fraud review is in progress for the order. Payment cannot be processed until the review has been completed.
     *
     * @return $this
     */
    public function setUnderReview($under_review)
    {
        $this->container['under_review'] = $under_review;

        return $this;
    }

    /**
     * Gets chargeback
     *
     * @return bool
     */
    public function getChargeback()
    {
        return $this->container['chargeback'];
    }

    /**
     * Sets chargeback
     *
     * @param bool $chargeback This will be returned as true if a chargeback has been issued against the order. An outstanding chargeback disables the ability to submit a refund against the order.
     *
     * @return $this
     */
    public function setChargeback($chargeback)
    {
        $this->container['chargeback'] = $chargeback;

        return $this;
    }

    /**
     * Gets reason
     *
     * @return string
     */
    public function getReason()
    {
        return $this->container['reason'];
    }

    /**
     * Sets reason
     *
     * @param string $reason Gives a reason for an order to be in a given state.
     *
     * @return $this
     */
    public function setReason($reason)
    {
        $this->container['reason'] = $reason;

        return $this;
    }

    /**
     * Gets expiry
     *
     * @return string
     */
    public function getExpiry()
    {
        return $this->container['expiry'];
    }

    /**
     * Sets expiry
     *
     * @param string $expiry If the order was created with Capture false, and the payment is authorized, the RFC 3339 time at which this order expires. If further authentication is required, this is the time by which that authentication must be completed.
     *
     * @return $this
     */
    public function setExpiry($expiry)
    {
        $this->container['expiry'] = $expiry;

        return $this;
    }

    /**
     * Gets action
     *
     * @return AllOfOrderAction
     */
    public function getAction()
    {
        return $this->container['action'];
    }

    /**
     * Sets action
     *
     * @param AllOfOrderAction $action action
     *
     * @return $this
     */
    public function setAction($action)
    {
        $this->container['action'] = $action;

        return $this;
    }

    /**
     * Gets times
     *
     * @return AllOfOrderTimes
     */
    public function getTimes()
    {
        return $this->container['times'];
    }

    /**
     * Sets times
     *
     * @param AllOfOrderTimes $times times
     *
     * @return $this
     */
    public function setTimes($times)
    {
        $this->container['times'] = $times;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
